// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"

#include "Actuation/Propulsion/Propulsion.h"
#include "Common/Types.h"

#include "PropellerPropulsion.generated.h"

// Editor Declarations
UENUM()
enum class EPropellerRotationDirection : int8
{
	Positive = 1			UMETA(DisplayName = "+Z"),
	Negative = -1			UMETA(DisplayName = "-Z")
};

USTRUCT()
struct FConstantSpeedPropellerPhysicsParameters
{
	GENERATED_BODY()
	// These are our propeller parameters for a specific propeller speed.
	UPROPERTY(EditAnywhere)
	float n; // RPM
	UPROPERTY(EditAnywhere)
	TArray<float> J;
	UPROPERTY(EditAnywhere)
	TArray<float> CT;
	UPROPERTY(EditAnywhere)
	TArray<float> CP;
};

USTRUCT()
struct FPropellerPhysicsParameters
{
	GENERATED_BODY()
	// We will have a set of propeller parameters, based on the propeller speed. 
	UPROPERTY(EditAnywhere)
	TArray<FConstantSpeedPropellerPhysicsParameters> ConstantSpeedPropellerPhysicsParameters;

	UPROPERTY(EditAnywhere, Meta = (Tooltip = "The rotation direction of the propeller (Right Hand Rule) about the Z axis."))
	EPropellerRotationDirection RotationDirection;

	UPROPERTY(EditAnywhere, Meta = (Tooltip = "Lumped drag coefficient (default as per Bangura, 2017) (Unitless)"))
	float Cd = 0.01;

	UPROPERTY(EditAnywhere, Meta = (Tooltip = "Mass moment of inertia of the propeller about the Z axis (kg.m^2)"))
	float Izz;

	UPROPERTY(EditAnywhere, Meta = (Tooltip = "True propeller diameter. This might differ from the manufacturer list diameter, so see the geometry data. (m)"))
	float D;
};

// Calculation Structs
struct FPropellerPhysicsCalculationParameters
{
	bool bPhysicsParametersInitialized = false;

	// Variables
	TArray<float> NArray; // Array of propeller speeds
};

// Results Structs
struct FAerodynamicConstantResults
{
	float CT;
	float CP;

	FAerodynamicConstantResults(float CT, float CP) : CT(CT), CP(CP) {};
};

// State Structs
USTRUCT(BlueprintType)
struct FPropellerState
{
	GENERATED_BODY()

	FVector V = FVector(0); // Current propeller airstream inflow velocity (m/s)

	float omega = 0.0f; // Current propeller rotational speed (rad/s)
	float Rho = 0.0f; // Current air density at the propeller (kg/m^3)
	float J = 0.0f; // Current advance ratio (unitless)
	float AerodynamicConstant = 0.0f; // The aerodynamic constant for thrust (rho * n^2 * D^4).

	// Rotations from world to unreal and vice versa.
	FRotator Rwu;
	FRotator Ruw;
};

UCLASS(ClassGroup = "Propulsion", meta = (BlueprintSpawnableComponent))
class SKYPHYS_API UPropellerPropulsionStaticMeshComponent : public UPropulsionStaticMeshComponent
{
	GENERATED_BODY()

public:
	UPropellerPropulsionStaticMeshComponent();

	// Apply the propeller command
	// This will then invoke the actuator driving the propeller and handle the dynamics associated with this
	//
	// @param dtCmd: The unitless command signal (expect this to be between 0 and 1)
	virtual void ApplyActuatorCommand(const float dtCmd, const float DeltaTime) override;

	// Get Propeller Forces and Moments in the world frame. 
	// Note that the propeller frame will generally be with the z-axis pointing down for a multirotor, or toward the back of the aircraft for a fixed wing. 
	// Right hand rule will then determine what "clockwise" and "anticlockwise" mean. 
	// "Positive thrust", or in other words actually actively generating thrust, will result in a negative Z thrust in the propeller body frame. 
	//
	// Calculate the forces and moments generated by this propeller in the world frame, at the origin of the propeller frame (ie. you will need to get the moments yourself!)
	// 
	// @param Rho: Air density (kg/m^3)
	// @param SystemOmega: Root body rotational velocity in the world frame (rad/s)
	// @param Vw: Wind velocity in the world frame (NEU) (m/s)
	// 
	// @return The forces and moments generated by this propeller in the world frame (N, Nm)
	virtual FForcesAndMoments GetForcesAndMoments(float Rho, FVector Vw, FVector SystemOmega) override;

	// Get the current propeller speed (in SI units)
	//
	// @return The current propeller speed (rad/s)
	virtual float GetMotionState() override;

private:
	UPROPERTY(EditAnywhere, Category = "Propeller Physics", Meta = (Tooltip = "Maximum propeller rotational speed (RPM)", AllowPrivateAccess = "true"))
	float MaxN;

	UPROPERTY(EditAnywhere, Category = "Propeller Physics", meta = (AllowPrivateAccess = "true"))
	FPropellerPhysicsParameters PhysicsParameters;

	// State Parameters
	FPropellerState PropellerState;

	// Initialize the system
	void InitializePropellerPhysics();

	// Update the system parameters
	void UpdatePropellerState(float Rho, FVector Vw);

	// Calculate the forces generated by this propeller in the propeller frame
	FVector CalculateForces(float CT);
	// Thrust, T, forces on the propeller (ie. in the (0, 0, Vz)b direction)
	FVector CalculateThrustForces(float CT);
	// Side, H forces on the propeller (ie. in the (Vx, Vy, 0)b plane)
	FVector CalculateSideForces(float T);
	// Calculate the moments generated by this propeller in the propeller frame
	FVector CalculateMoments(float CP, FVector SystemOmega);
	// Calculate the aerodynamic moments on the propeller (ie. via CQ)
	FVector CalculateAerodynamicMoments(float CP);
	// Calculate the gyroscopic moments on the propeller
	FVector CalculateGyroscopicMoments(FVector SystemOmega);

	// Utilities

	// Transform from the world frame to the propulsor body frame
	FVector TransformFromWorldToBody(FVector WorldVector);
	// Transform from the propulsor body frame to the world frame
	FVector TransformFromBodyToWorld(FVector BodyVector);

	// Get aerodynamic constants
	//
	// @param n Propeller speed (RPM)
	// @param J Advance ratio (unitless)
	//
	// @return Aerodynamic Constants
	FAerodynamicConstantResults GetAerodynamicConstants(float n, float J);

	// Calculation Parameters
	FPropellerPhysicsCalculationParameters PropellerPhysicsCalculationParameters;

};